# GophKeeper

Учебный проект представляет собой клиент-серверную систему, позволяющую пользователю надёжно и безопасно хранить логины, пароли, бинарные данные и прочую приватную информацию.

## Основные FR

GophKeeper — клиент-серверная система для безопасного хранения и передачи конфиденциальной информации:

- Пары логин-пароль
- Текст
- Бинарные данные (файлы)

Клиент — CLI утилита с интерактивным режимом работы. Сервер — сервис на Go.

### Основные сценарии:

- регистрация
- аутентификация
- загрузка пары логин-пароль
- загрузка текста
- загрузка файлов (можно грузить большие файлы)

Упор в системе — на безопасность.\
Данные сохраняются с ключом (label) для последующего извлечения. Должна быть возможность одному пользователю авторизоваться с нескольких клиентов с разных устройств, и система должна корректно обрабатывать конкурентные запросы и разрешать конфликты.

Вместе с данными можно передавать метаинформацию в plain text.

Также, клиент должен давать пользователю возможность получить информацию о версии и дате сборки бинарного файла клиента.

## Технические решения

1. **Аутентификация** — JWT с refresh token. Access token будет жить 15 минут, refresh token будет храниться в памяти. Таким образом каждый раз при запуске нужно будет логиниться, но access token будет обновляться — это безопаснее, если клиент постоянно запущен.

2. **Шифрование на клиенте** (AES-256), передаём уже зашифрованные данные через HTTPS + `multipart/form-data` для файлов. У клиента есть мастер-пароль, из которого генерируем ключ шифрования с помощью [`github.com/alexedwards/argon2id`](https://github.com/alexedwards/argon2id). Таким образом ключ не надо передавать в разные инстансы клиента на разных устройствах. User-specific соль будет генерироваться при регистрации, храниться на сервере и передаваться клиенту при логине. Ключ шифрования не сохраняется и живёт только в памяти клиента после логина.

3. **Конфликты и синхронизация** — делаем optimistic update с передачей версии с клиента и 409 ошибкой, если на сервере хранится версия ≠ переданной с клиента. Данные пишем в транзакции. Это проще, чем делать очереди на запись, и позволит избежать блокировок, например, если одновременно передают большие файлы с одним лейблом.

4. **API загрузки и получения** — 4 отдельных метода для загрузки:

   - загрузить текст

   - загрузить логин-пароль

   - загрузить данные карты

   - загрузить файл

   - и один универсальный метод для получения данных `GET /api/records`. При этом для файлов в теле ответа будет ссылка на скачивание, например: `/api/files/1/download`. Клиент сначала покажет метаданные, полученные из универсального метода, и предложит скачать файл.&#x20;

5. **Хранение данных**. PostgreSQL — для хранения метаданных, данных пользователей, зашифрованных данных логин-пароль, текстов и данных карт. MinIO — для хранения зашифрованных файлов.

## Дополнительные материалы

- [C4 диаграммы](./docs/static/GophKeeper-C4.png)
- [Описание API](./docs/routes.md)
- [Структура базы данных](./docs/db.md)

## Ограничения

1. Пользователь не сможет поменять пароль.
2. При удалении — удаляем из БД и MinIO. Версионирование не поддерживаем.